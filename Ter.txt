#First we need to install Terraform and install Azure CLI (*to allow Terraform to authenticate and access the Azure API) and install Terraform extension for Visual Studio code 
#and go in terminal to   az login, than choose your login (or other option az login --use-device-code  then go throuth the link and write a code) and you can validate it with    az account show command,  than we need to have Azure storage account and we need to read documentation for Azure(Azure Provider: Authenticating using the Azure CLI) and Terraform#


# It is strongly recommended to use the required_providers block to set the Azure Provider source and version being used
# Azure Provider source and version being used
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}

# Configure the Microsoft Azure Provider (specify) (how we will do the connection) if it is wrong name of provider --error
provider "azurerm" {
  features {}
}
#than run terraform fmt to make it nice looking
#run terraform init
# after that it will create terraform files: Terraform providers its like .exe file and .terraform.lock.hcl in this file you store your version of the provider





### this is for  CREATE RESOURCE GROUP
###resource "azurerm_resource_group" "aac-rg" {
###name     = "aac-resource"
###location = "West Europe"
###tags = {
###environment = "dev"
###}
###}






#FOR IMPORT RESOURCE GROUP
#data-benchmarking is the name of resource group if tags you can also write tags -- you can find it in tags info about your resource group
resource "azurerm_resource_group" "data-benchmarking" {
  name     = "data-benchmarking"
  location = "West Europe"
  tags = {
    owner       = "Juuso Linen"
    environment = "Testing"
    project     = "Työkokeilu"
  }
}

resource "azurerm_resource_group" "data-benchmarking-2" {
  name     = "data-benchmarking-2"
  location = "West Europe"
  tags = {
    owner       = "Juuso Linen"
    environment = "Testing"
    project     = "Työkokeilu"
  }
}

resource "azurerm_resource_group" "data-benchmarking-3" {
  name     = "data-benchmarking-3"
  location = "West Europe"
  tags = {
    owner       = "Juuso Linen"
    environment = "Testing"
    project     = "Työkokeilu"
  }
}
#   then run in terminal    terraform import azurerm_resource_group.data-benchmarking /subscriptions/fa11dc11-111f-1111-11c1-e1c11eb11acb/resourceGroups/data-benchmarking   (Here you need to copy Resource ID and Subscraptions ID) same with 2 others resource
#run terraform fmt, and then terraform plan it shows us what it will be built if we run "apply"
#than deploy it by running       terraform apply  in terminal to deploy




#KEY VAULT PART









#than go to azurerm_virtual_network documentation
#then in resource_group_name = azurerm_resource_group.data-benchmarking-virtual-network.name    name must be depend from resources
resource "azurerm_virtual_network" "virtualnetwork" {
  name                = "virtualnetwork"
  location            = azurerm_resource_group.data-benchmarking.location
  resource_group_name = azurerm_resource_group.data-benchmarking.name
  address_space       = ["10.0.0.0/16"]
  tags = {
    environment = "Testing"
  }
}
#create a subnets   this for staticweb
resource "azurerm_subnet" "subnet-1" {
  name                 = "subnet-1"
  resource_group_name  = azurerm_resource_group.data-benchmarking.name
  virtual_network_name = azurerm_virtual_network.virtualnetwork.name
  address_prefixes     = ["10.0.1.0/24"]

}





resource "azurerm_virtual_network" "virtualnetwork2" {
  name                = "virtualnetwork2"
  location            = azurerm_resource_group.data-benchmarking-2.location
  resource_group_name = azurerm_resource_group.data-benchmarking-2.name
  address_space       = ["10.1.0.0/16"]

  tags = {
    environment = "Testing"
  }
}



#subnet for web app
resource "azurerm_subnet" "subnet-2" {
  name                 = "subnet-2"
  resource_group_name  = azurerm_resource_group.data-benchmarking-2.name
  virtual_network_name = azurerm_virtual_network.virtualnetwork2.name
  address_prefixes     = ["10.1.2.0/24"]

}


resource "azurerm_virtual_network" "virtualnetwork3" {
  name                = "virtualnetwork3"
  location            = azurerm_resource_group.data-benchmarking-3.location
  resource_group_name = azurerm_resource_group.data-benchmarking-3.name
  address_space       = ["10.2.0.0/16"]

  tags = {
    environment = "Testing"
  }
}

#subnet for database
resource "azurerm_subnet" "subnet-3" {
  name                 = "subnet-3"
  resource_group_name  = azurerm_resource_group.data-benchmarking-3.name
  virtual_network_name = azurerm_virtual_network.virtualnetwork3.name
  address_prefixes     = ["10.2.3.0/24"]
}
#after that terraform fmt , terraform init, terraform plan, terraform apply
#Virtual network has been created
# than manually in terraform.tfstate file you need to modify   1) it shood be stored remotely in some storage Blob Storage, AWS S3  or spacelift or terraform cloud...
#in terminal     terraform state list we can see all resources we have, for more details     terraform state show name_of_the_resource
#or to see all resouces      terraform show

# terraform plan -destroy          show the plan what will be destroyed           terraform apply -destroy      destroy everything!!!!!!!!
#!!!!!if you DELETE something by mistake you have terraform.tfstate.backup file, you need to delete terraform.tfstate file and rename terraform.tfstate.backup file to terraform.tfstate.










#App Service Plan for the web app
resource "azurerm_service_plan" "app_plan" {
  name                = "app_plan"
  location            = azurerm_resource_group.data-benchmarking-2.location
  resource_group_name = azurerm_resource_group.data-benchmarking-2.name
  os_type             = "Linux"
  sku_name            = "B1" #Free version(F1) doesnt support websocket which is required for Streamlit
}
#Web App
resource "azurerm_linux_web_app" "webapp" {
  name                = "webapp"
  resource_group_name = azurerm_resource_group.data-benchmarking-2.name
  location            = azurerm_resource_group.data-benchmarking-2.location
  service_plan_id     = azurerm_service_plan.app_plan.id


  app_settings = {
    WEBSITE_RUN_FROM_PACKAGE       = "1"
    SCM_DO_BUILD_DURING_DEPLOYMENT = "true"
  }

  site_config {
    always_on          = true
    websockets_enabled = true
    application_stack { python_version = "3.9" }
  }

  tags = {
    environment = "testing"
  }

  #To connect web app to database
  connection_string {
    name  = "Database"
    type  = "PostgreSQL"
    value = "Server=tcp:azurerm_postgresql_server.postgresql_server.fully_qualified_domain_name Database=azurerm_postgresql_database.postgredatabase.name;User ID=azurerm_postgresql_server.postgresql_server.administrator_login;Password=azurerm_postgresql_server.postgresql_server.administrator_login_password;Trusted_Connection=False;Encrypt=True;"
  }

}







































#PostgreSQL Server for the database
resource "azurerm_postgresql_server" "postgresql_server" {
  name                  = "my-postgresql-server" # your server name
  location              = azurerm_resource_group.data-benchmarking-3.location
  resource_group_name   = azurerm_resource_group.data-benchmarking-3.name
  sku_name              = "B_Gen5_1" # Change this to your desired SKU
  storage_mb            = 5120       # Change this to your desired storage size
  version               = "11"
  backup_retention_days = 7 #from 7 to 35
  #geo_redundant_backup_enabled = false
  #delegated_subnet_id    = azurerm_subnet.default.id
  #private_dns_zone_id    = azurerm_private_dns_zone.default.id
  #public_network_access_enabled    = false
  ssl_enforcement_enabled = true
  #ssl_minimal_tls_version_enforced = "TLS1_2"
  administrator_login          = "dbadmin" # Change this to your desired admin username
  administrator_login_password = "Admin"   # Change this to your desired admin password

  auto_grow_enabled = true
  #depends_on = [azurerm_private_dns_zone_virtual_network_link.default]
}

# PostgreSQL Database
resource "azurerm_postgresql_database" "postgredatabase" {
  name                = "postgredatabase"
  resource_group_name = azurerm_resource_group.data-benchmarking-3.name
  server_name         = azurerm_postgresql_server.postgresql_server.name
  charset             = "UTF8"
  collation           = "English_United States.1252" #??????
}
# Firewall rules to allow access to the database SERVER!
#firewall_rule {
# name                        = "AllowAllWindowsAzureIps"
#start_ip_address            = "0.0.0.0"
#end_ip_address              = "0.0.0.0"
#}

##resource "azurerm_postgresql_firewall_rule" "firewall_rule" {
## name                = "office"
##resource_group_name = azurerm_resource_group.data-benchmarking-3.name
##server_name         = azurerm_postgresql_server.data-benchmarking-3.name
##start_ip_address    = "40.112.0.0"
##end_ip_address      = "40.112.255.255"
##}































#for static we do not need IP
#for for the static web app(subnet-1) to create a public IP     read ducumentation azurerm_public_ip            Dynamic - !!!Public IP Addresses aren't allocated until they're assigned to a resource (such as a Virtual Machine or a Load Balancer) by design within Azure. See ip_address argument. THE IP address will not be known after apply!!! This is how Azure works, when its Dynamic will not show untill we deploy other resources
resource "azurerm_public_ip" "static_web_app_ip" {
  name                = "static_web_app_ip"
  location            = azurerm_resource_group.data-benchmarking.location
  resource_group_name = azurerm_resource_group.data-benchmarking.name
  allocation_method   = "Static" ###?????

  tags = {
    environment = "testing"
  }
}
#terraform plan      terraform apply      terraform state list    terraform state show azurerm_public_ip.IP_name    to see what is inside

# Associate the public IP with the NIC of the static web app    #???I DO NOT NEED??
#resource "azurerm_network_interface_ip_configuration" "nic_ip_config_static_web" {
#name                                    = "internal"
# subnet_id                               = azurerm_subnet.subnet-1.id
# private_ip_address_allocation          = "Dynamic"
# public_ip_address_id                   = azurerm_public_ip.static_web_app_ip.id
#}






































#network_security_group for static web app(subnet-1)
#to set up security write name and set Inbound in direction (bacause it is access to our nets not out) and change TCP to "*" to allow ICMP...    source_address_prefix= "*" allows access to anyone see my IP address, its better to change to your public IP address for ex.(123.123.123.123/32)
#network Security Group for the static web app (subnet-1)
resource "azurerm_network_security_group" "network-sg1" {
  name                = "resource-security-group-1"
  location            = azurerm_resource_group.data-benchmarking.location
  resource_group_name = azurerm_resource_group.data-benchmarking.name
}
#network_security_group for web app(subnet-2)
resource "azurerm_network_security_group" "network-sg2" {
  name                = "resource-security-group-2"
  location            = azurerm_resource_group.data-benchmarking-2.location
  resource_group_name = azurerm_resource_group.data-benchmarking-2.name
}
#network_security_group for database(subnet-3)
resource "azurerm_network_security_group" "network-sg3" {
  name                = "resource-security-group-3"
  location            = azurerm_resource_group.data-benchmarking-3.location
  resource_group_name = azurerm_resource_group.data-benchmarking-3.name
}


# Add NSG rules for static web app subnet
resource "azurerm_network_security_rule" "static_web" {
  name                        = "static_web"
  priority                    = 100
  direction                   = "Inbound"
  access                      = "Allow"
  protocol                    = "*"
  source_port_range           = "*"
  destination_port_range      = "*"
  source_address_prefix       = "Internet" # Allow access from the public internet
  destination_address_prefix  = "*"
  resource_group_name         = azurerm_resource_group.data-benchmarking.name
  network_security_group_name = azurerm_network_security_group.network-sg1.name
}











































#Than terraform fmt   then      terraform plan    terraform apply and than      terraform state list   to check all resources we have
#than we need to associate new security group with our subnet so it can be used to protect it   read documentation azurerm_subnet_network_security_group_association
resource "azurerm_subnet_network_security_group_association" "static_web" {
  subnet_id                 = azurerm_subnet.subnet-1.id
  network_security_group_id = azurerm_network_security_group.network-sg1.id
}
#terraform fmt      terraform plan  it shown what it want to add network_security_group_id  and  subnet_id that will allow our network security group to protect our subnet       terraform apply
# Associate the network security group with the web app subnet
resource "azurerm_subnet_network_security_group_association" "web_app" {
  subnet_id                 = azurerm_subnet.subnet-2.id
  network_security_group_id = azurerm_network_security_group.network-sg2.id
}

# Associate the network security group with the database subnet
resource "azurerm_subnet_network_security_group_association" "database" {
  subnet_id                 = azurerm_subnet.subnet-3.id
  network_security_group_id = azurerm_network_security_group.network-sg3.id
}












































# Add NSG rules for web app subnet
resource "azurerm_network_security_rule" "web-app" {
  name                        = "web-app"
  priority                    = 100
  direction                   = "Inbound"
  access                      = "Allow"
  protocol                    = "*"
  source_port_range           = "*"
  destination_port_range      = "*"
  source_address_prefix       = azurerm_subnet.subnet-1.address_prefixes[0]
  destination_address_prefix  = azurerm_subnet.subnet-2.address_prefixes[0]
  resource_group_name         = azurerm_resource_group.data-benchmarking-2.name
  network_security_group_name = azurerm_network_security_group.network-sg2.name
}


# Add NSG rules to allow web app access to the database
resource "azurerm_network_security_rule" "web_app_to_database" {
  name                        = "web_app_to_database"
  priority                    = 100
  direction                   = "Inbound"
  access                      = "Allow"
  protocol                    = "*"
  source_port_range           = "*"
  destination_port_range      = "*"
  source_address_prefix       = azurerm_subnet.subnet-2.address_prefixes[0] #Allow access from the web app subnet
  destination_address_prefix  = azurerm_subnet.subnet-3.address_prefixes[0]
  resource_group_name         = azurerm_resource_group.data-benchmarking-3.name
  network_security_group_name = azurerm_network_security_group.network-sg3.name
}





# Create the storage account for the database
resource "azurerm_storage_account" "storage_account_for_database" {
  name                     = "storageaccountdb"
  location                 = azurerm_resource_group.data-benchmarking-3.location
  resource_group_name      = azurerm_resource_group.data-benchmarking-3.name
  account_tier             = "Standard"
  account_replication_type = "LRS"
  # Add any required network rules for the storage account (if applicable)
  # Example:
  # network_rules {
  #   default_action = "Deny"
  #   ip_rules       = ["123.123.123.123/32"] # Replace with the specific IP allowed to access the database
  # }
}






# create the storage account for the static webapp
resource "azurerm_storage_account" "storageaccount1" {
  name                = "storageforstaticweb"
  location            = azurerm_resource_group.data-benchmarking.location
  resource_group_name = azurerm_resource_group.data-benchmarking.name

  account_tier             = "Standard"
  account_replication_type = "LRS"
  account_kind             = "StorageV2"
  #allow_https_traffic_only = true                                                        #if do not want access to this
  #allow_blob_public_access = true

  static_website {
    index_document = "index.html"
  }
}
#resource "azurerm_storage_container" "forstatic" {   no need
# name                  = "$web"     no need
#storage_account_name  = azurerm_storage_account.staticstorage.name    no need
#container_access_type = "blob"   no need
#}    no need

resource "azurerm_storage_blob" "blobforstatic" {
  name                   = "index.html"
  storage_account_name   = azurerm_storage_account.storageaccount1.name
  storage_container_name = "$web"
  type                   = "Block"
  content_type           = "text/html"
  source_content         = file("C:\\Users\\kambiy230\\Desktop\\Coding\\terraform_folder\\index.html") #path to my index.html file
}
# Add any required network rules for the storage account (if applicable)
# Example:
# network_rules {
#   default_action = "Deny"
#   ip_rules       = ["123.123.123.123/32"] # Replace with the specific IP allowed to access the database
# }
#resource "azurerm_storage_static_website" "websitehosting" {
#name                 = azurerm_storage_account.staticstorage.name
#resource_group_name  = azurerm_resource_group.data-benchmarking.name
#index_document       = "index.html"
#error_404_document   = "404.html"  # we can provide a custom 404 error page
#}


# Output the storage account primary endpoint URL
output "static_website_endpoint" {
  value = azurerm_storage_account.storageaccount1.primary_web_endpoint
}

# Output the web app endpoint URL
##output "web_app_url" {
##value = azurerm_app_service.web_app.default_site_hostname
##}
# Output the database connection string (you'll need to provide this in the app settings of the web app)
output "database_connection_string" {
  value       = azurerm_storage_account.storage_account_for_database.primary_connection_string
  description = "database connection string"
  sensitive   = true
}



















































#for virtual machine to create a public IP     read ducumentation azurerm_public_ip            Dynamic - !!!Public IP Addresses aren't allocated until they're assigned to a resource (such as a Virtual Machine or a Load Balancer) by design within Azure. See ip_address argument. THE IP address will not be known after apply!!! This is how Azure works, when its Dynamic will not show untill we deploy other resources

resource "azurerm_public_ip" "ip_web" {
  name                = "ip_web"
  resource_group_name = azurerm_resource_group.data-benchmarking-2.name
  location            = azurerm_resource_group.data-benchmarking-2.location
  allocation_method   = "Dynamic"

  tags = {
    environment = "testing"
  }
}
#terraform plan      terraform apply      terraform state list    terraform state show azurerm_public_ip.IP_name    to see what is inside


#need create network interface that will attach to our virtual machine in order to provide network connectivity. This NIC will recieve its public IP address from created IP address
#read documentation azurerm_network_interface    
resource "azurerm_network_interface" "networkinterface_NIC" {
  name                = "networkinterface-nic"
  location            = azurerm_resource_group.data-benchmarking-2.location
  resource_group_name = azurerm_resource_group.data-benchmarking-2.name

  ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.subnet-2.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = azurerm_public_ip.ip_web.id
  }
  tags = {
    environment = "testing"
  }
}
#terraform fmt    terraform plan     terraform apply    terraform state list(to see what we have)      terraform state show azurerm_network_interface.networkinterface_NIC

#we will create SSH key pair (IN admin_ssh_key block), this will be used by the Linux VM resource we created so we can SSH into it later. We have to create the key first
#in Terminal ssh-keygen -t rsa     (to create rsa key pair) and write where you want to save it (C:\Users\kambiy230/.ssh/Azurekey), and password if you want
#than in Terminal run     ls ~/.ssh and you will see Azurekey and Azurekey pub files.    # in code: admin_ssh_key block file function is to get key from there (file("~/.ssh/Azurekey.pub"))
#  https://azureprice.net/ the link with the prices for virtual machine
resource "azurerm_linux_virtual_machine" "virtual_machine1" {
  name                  = "virtul-machine1"
  resource_group_name   = azurerm_resource_group.data-benchmarking-2.name
  location              = azurerm_resource_group.data-benchmarking-2.location
  size                  = "Standard_B1s"
  admin_username        = "adminuser"
  network_interface_ids = [azurerm_network_interface.networkinterface_NIC.id]

  custom_data = filebase64("C:\\Users\\kambiy230\\Desktop\\Coding\\terraform_folder\\customdata.tpl") #custom data code file to deploy docker

  admin_ssh_key {
    username   = "adminuser"
    public_key = file("~/.ssh/Azurekey.pub") #read filessh
  }

  os_disk {
    caching              = "ReadWrite"
    storage_account_type = "Standard_LRS"
  }

  source_image_reference {
    publisher = "Canonical"
    offer     = "0001-com-ubuntu-server-focal"
    sku       = "20_04-lts"
    version   = "latest"
  }
#THIS PART need to be added after creation Virtual machine
#provisioner "local-exec" {
#command = templatefile("${var.host_os}-ssh-script.tpl", {
#  hostname = self.public_ip_address,       #how you access the public ip address
#  user = "adminuser",
#  identifyfile = "~/.ssh/Azurekey"
#})
#interpreter = ["Powershell","-Command"]         #which program(shell) we use to run the script
#}
  
  tags = {
    environment = "testing"
  }
}
#GET IP
data "azurerm_public_ip" "ip_web-data" {
  name                = azurerm_public_ip.ip_web.name
  resource_group_name = azurerm_resource_group.data-benchmarking-2.name
}
#Get output
output "public_ip_address" {
  value = "${azurerm_linux_virtual_machine.virtual_machine1.name}: ${data.azurerm_public_ip.ip_web-data.ip_address}"
}
#terraform fmt      terraform plan  (file function adds here doc synthax to the beginning and end of public_key)   terraform apply
#AFTER we cerate virtual machine    run in Terminal terraform state list and copy azurerm_linux_virtual_machine.virtual_machine1         and than terraform state show azurerm_linux_virtual_machine.virtual_machine1
#Now we can see public ip address.      you can run             ssh -i ~/.ssh/Azurekey adminuser@52.174.166.45        <--- this is Your public_ip_address
#now we are logged in Virtual Machine
#Than if you run in terminal      lsb_release -a      you can see that you are now into Ubuntu instance
#if you need exit run     exit     in terminal









#now we utilize the custom data argument to bootstrap our instance and install the Docker engine. It will allow us to have a Linux VM instance deployed with Docker ready to go for development needs.
#1) To create a new file in Visual Studio Code, for example   customdata.tpl         tpl is the extension typically used for template files.

#THIS IS  FILE INSIDE save it.            we need it to install Docker on our machine
##    #!/bin/bash
##sudo apt-get update -y &&
##sudo apt-get install -y \
##apt-transport-https \
##ca-certificates \
##curl \
##gnupg-agent \
##software-properties-common &&
##curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - &&
##sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" &&
##sudo apt-get update -y &&
##sudo apt-get install docker-ce docker-ce-cli containerd.io -y &&
##sudo usermod -aG docker ubuntu





#to add the custom data argument we need to add custom_data block to our code. To add     filebase64 Function     it reads the contents of a file at the given path and encodes it in base64 string, thats what custom data field for Azure is expecting
# when custom_data block is ready run terrafrm fmt       terraform plan         terraform apply
#It is not changing because customdata file requires VM to be redeployed, so it will destroy and replace a with new one
#when its ready we need ip address,    run terraform state list and copy   azurerm_linux_virtual_machine.virtual_machine1 , terraform state show azurerm_linux_virtual_machine.virtual_machine1, now you can see new public_ip_address
#Ctrl+R       you can fine your old command lines   than run it with new ip address    (ssh -i ~/.ssh/Azurekey adminuser@20.16.21.187), now we are in new VM
#run docker --version, you can see the version of docker

#we need to install the remote ssh extension in Virtual Studio Code wich allow VS code to open a remote terminal in our Virtual Machine.
#Go to extensions and install remote - SSH
#open in    View - Command palette -  remote-SSH:Add New SSH Host and then write   ssh admin@admin.com and press enter, open first config file press open.

#create a new file for example for windows       windows-ssh-script.tpl copy here info from config file
##add-content -path c:/Users/kambiy230/.ssh/config -value @'
##Host admin.com
##HostName admin.com
##User admin
##IdentityFile  

#create a new file for example for Linux      linux-ssh-script.tpl copy here info from config file 
## cat << EOF >> c:/Users/kambiy230/.ssh/config 
##Host admin.com
##HostName admin.com
##User admin
##IdentityFile 
##EOF
#we can connect to our host using VS code. We will utilize a provisioner to configure the VS code on our local terminal to be able to ssh into our remote VM.
#you dont want to use provisioners for every deployment, because you can not see was it success or failure, and there is no rollback, you can just run it again. So the best option to add information to our config file on our local terminal.
#IF YOU NEED simple to do use provisioner. If I configuring A REMOTE INSTANCE best use User data, custom data, or another type of application such as Ansible.

#go to Terraform Provisioners website there are provisions like: self(that will extract attribute you need from deployment, public ip, or private ip...) ,  creation-time and destroy-time provisioner  (when you destroy the script)

#ONLY NOW (after all have been deployed) we need to add this provision in azurerm_linux_virtual_machine block of the code (before tags)
##provisioner "local-exec"{   #will be running locally
##command = templatefile("windows-ssh-script.tpl", {
##hostname = self.public_ip_address,       #how you access the public ip address
##user = "adminuser",
##identifyfile = "~/.ssh/Azurekey"
##})
##interpreter = ["Powershell","-Command"]         #which program(shell) we use to run the script            for Mac or linux ["bash", "-c"]

#after that run      terraform plan      so it shows there is no changes , we need to destroy and REAPPLY it.
#To do this        terraform state list   and copy VM         than run          terraform apply  -replace azurerm_linux_virtual_machine.virtual_machine1







#Than in VSCode go to View-Command Palette(CTRL+SHIFT+P)   Write: Remote-SSH: Connect to Host         than choose IP and choose Linux and continue
#now we are in VM and we can check       docker -version   (so now we are in Remote terminal)




#Using data sources    for what??
#we can add this part of the code and run     terraform apply -refresh-only and yes

##data "azurerm_public_ip" "ip_web-data" {
 ## name                = azurerm_public_ip.ip_web.name
  ##resource_group_name = azurerm_resource_group.data-benchmarking-2.name
##}






#Outputs parts        read     Declaring an Output Value Terraform        !Outputs are only rendered when Terraform applies your plan. Running "terraform plan" will not render outputs.
##output "public_ip_address" {
##  value = "${azurerm_linux_virtual_machine.virtual_machine1.name}: ${data.azurerm_public_ip.ip_web-data.ip_address}"
## }
#run terraform output public_ip_address       we can see IP address



#Variables
#If its not specify you need to write it everytime
#terraform.tfvars here we define our variables (it is SENSITIVE file) do not need send it to repository
